
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xml:lang="en-us" lang="en-us">
<head><meta xmlns="http://www.w3.org/1999/xhtml" name="description" content="PARTITION is an event series processing language that partitions the rows of a dataset, orders the rows sequentially (typically by a timestamp), and searches for matching patterns in a set of rows. ..."/><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><meta name="copyright" content="(C) Copyright 2005"/><meta name="DC.rights.owner" content="(C) Copyright 2005"/><meta name="DC.Type" content="reference"/><meta name="DC.Title" content="PARTITION"/><meta name="abstract" content="PARTITION is an event series processing language that partitions the rows of a dataset, orders the rows sequentially (typically by a timestamp), and searches for matching patterns in a set of rows. Computed fields that are defined in a dataset using a PARTITION expression are considered event series processing computed fields. Event series processing computed fields are processed differently than regular computed fields. Instead of computing values from the input of a single row, they compute values from inputs of multiple rows in the dataset."/><meta xmlns="http://www.w3.org/1999/xhtml" name="description" content="PARTITION is an event series processing language that partitions the rows of a dataset, orders the rows sequentially (typically by a timestamp), and searches for matching patterns in a set of rows. Computed fields that are defined in a dataset using a PARTITION expression are considered event series processing computed fields. Event series processing computed fields are processed differently than regular computed fields. Instead of computing values from the input of a single row, they compute values from inputs of multiple rows in the dataset."/><meta name="DC.Relation" scheme="URI" content="../../reference/expression_language/row_general_functions_top.html"/><meta name="DC.Format" content="XHTML"/><meta name="DC.Identifier" content="ref_func_partition"/><link rel="stylesheet" type="text/css" href="../../oxygen-webhelp/resources/css/commonltr.css"><!----></link><title>PARTITION</title><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><link rel="stylesheet" type="text/css" href="../../oxygen-webhelp/resources/css/commonltr.css"><!----></link><link rel="stylesheet" type="text/css" href="../../oxygen-webhelp/resources/css/webhelp_topic.css"><!----></link><link rel="stylesheet" type="text/css" href="../../oxygen-webhelp/resources/skins/skin.css"><!----></link><link rel="stylesheet" type="text/css" href="../../oxygen-webhelp/resources/css/jquery.realperson.css"><!----></link><link rel="stylesheet" type="text/css" href="../../oxygen-webhelp/resources/css/comments.css"><!----></link><link rel="stylesheet" type="text/css" href="../../oxygen-webhelp/resources/css/jquery.cleditor.css"><!----></link><link rel="stylesheet" type="text/css" href="../../oxygen-webhelp/resources/css/admin.css"><!----></link><script type="text/javascript"><!--
          
          var prefix = "../../index.html";
          
          --></script><script type="text/javascript" src="../../oxygen-webhelp/resources/js/jquery-1.8.2.min.js"><!----></script><script type="text/javascript" src="../../oxygen-webhelp/resources/js/jquery.cookie.js"><!----></script><script type="text/javascript" src="../../oxygen-webhelp/resources/js/jquery-ui.custom.min.js"><!----></script><script type="text/javascript" charset="utf-8" src="../../oxygen-webhelp/resources/js/webhelp_topic.js"><!----></script><script type="text/javascript" charset="utf-8" src="../../oxygen-webhelp/resources/localization/strings.js"><!----></script><script type="text/javascript" charset="utf-8" src="../../oxygen-webhelp/resources/js/init.js"><!----></script><script type="text/javascript" charset="utf-8" src="../../oxygen-webhelp/resources/js/comments-functions.js"><!----></script></head>
<body onload="init('../../')" id="ref_func_partition">
<table class="nav"><tbody><tr><td colspan="2"><div id="printlink"><a href="javascript:window.print();" title="printThisPage"/></div><div id="permalink"><a href="#" title="linkToThis"/></div></td></tr><tr><td width="75%"><a class="navheader_parent_path" href="../../reference/expression_language/../../reference/expression_language/expression_reference_top.html" title="An expression computes or produces a value by combining fields (or columns), constant values, operators, and functions. Platfora has a built-in expression language. You use the language's functions and operators to create a computed field.">Expression and Query Language Reference</a> / <a class="navheader_parent_path" href="../../reference/expression_language/row_general_functions_top.html" title="General processing functions allow you to perform basic data evaluation operations, such as checking for NULL values or processing values based on certain input conditions.">General Processing Functions</a></td><td><div class="navheader">
<span class="navparent"><a class="link" href="../../reference/expression_language/row_general_functions_top.html" title="General processing functions allow you to perform basic data evaluation operations, such as checking for NULL values or processing values based on certain input conditions."><span class="navheader_label">Parent topic</span><span class="navheader_separator">: </span><span class="navheader_linktext">General Processing Functions</span></a></span>  </div></td></tr></tbody></table>

  <h1 class="title topictitle1">PARTITION</h1>

  
  
  <div class="body refbody"><div class="abstract">
    <div class="shortdesc"><samp class="ph codeph">PARTITION</samp> is an event series processing language that partitions the
      rows of a dataset, orders the rows sequentially (typically by a timestamp), and searches for
      matching patterns in a set of rows. Computed fields that are defined in a dataset using a
        <samp class="ph codeph">PARTITION</samp> expression are considered event series processing computed
      fields. Event series processing computed fields are processed differently than regular
      computed fields. Instead of computing values from the input of a single row, they compute
      values from inputs of multiple rows in the dataset.</div>

    
      <div class="note note"><span class="notetitle">Note:</span> The <samp class="ph codeph">PARTITION</samp> function can only be used to define a computed field in
      the dataset definition (pre-lens build). <samp class="ph codeph">PARTITION</samp> cannot be used to define a
      vizboard computed field. Unlike other expressions, <samp class="ph codeph">PARTITION</samp> expressions
      cannot be embedded within other functions or expressions - it must be a top-level
      expression.</div>

    
  </div>

    <div class="section"><h2 class="title sectiontitle">Syntax</h2>
      
      <pre class="pre codeblock" id="ref_func_partition__syntax_func_partition"><span class="ph synph"><span class="keyword kwd">PARTITION BY</span><span class="ph var">field_name</span>
   <span class="keyword kwd">ORDER BY</span> <span class="ph var">field_name</span> [<span class="keyword kwd">ASC</span>|<span class="keyword kwd">DESC</span>]
   <span class="keyword kwd">PATTERN</span> (<span class="ph var">pattern_expression</span>)
   <span class="keyword kwd">DEFINE</span> <span class="ph var">symbol_1</span> <span class="keyword kwd">AS</span> <span class="ph var">filter_expression</span>
               [,<span class="ph var">symbol_n</span> <span class="keyword kwd">AS</span> <span class="ph var">filter_expression</span> ] 
               [, ...] 
   <span class="keyword kwd">OUTPUT</span> <span class="ph var">output_expression</span> </span></pre>

      
      
    </div>

    
    <div class="section"><h2 class="title sectiontitle">Description</h2>
      
      <p class="p">To understand how event series processing works, we'll walk through a simple example of a
          <samp class="ph codeph">PARTITION</samp> expression.</p>

      <p class="p">This is a simple example of some weblog page view data. Each row represents a page view by a
        user at a give point in time. Session IDs are used to group together page views that happened in
        the same user session:</p>

      
      <div class="fig fignone"><img class="image" src="../../images/./dataset/computed_fields/esp_example_data.png"/>
        
      </div>

      <p class="p">Suppose you wanted to know how many sessions included the path of page visits to ‘home.html’
        then ‘products.html’ then ‘checkout.html’. You could define a <samp class="ph codeph">PARTITION</samp>
        expression that groups the rows by session, orders by time, and then iterates through the rows
        from top to bottom to find sessions that match the pattern:</p>

      <div class="p">
        <pre class="pre codeblock">PARTITION BY SessionID
ORDER BY Timestamp
PATTERN (A,B,C)   
    DEFINE A AS Page = "home.html",           
           B AS Page = "product.html",           
           C AS Page = "checkout.html"
OUTPUT "TRUE"</pre>

      </div>

      <div class="p">
        <ol class="ol">
          <li class="li">The <samp class="ph codeph">PARTITION BY</samp> clause partitions (or groups) the rows of the dataset by session. </li>

          <li class="li">Within each partition, the <samp class="ph codeph">ORDER BY</samp> clause sorts the rows by time (in ascending order
            by default). </li>

          <li class="li">Each <samp class="ph codeph">DEFINE</samp> clause specifies a condition used to evaluate a row, and binds that
            condition to a symbol that is then used in the <samp class="ph codeph">PATTERN</samp> clause. </li>

          <li class="li">The <samp class="ph codeph">PATTERN</samp> clause checks if the conditions are met in the specified order and
            frequency. This pattern says that there is a match whenever there are 3 consecutive rows that
            meet criteria A then B then C. </li>

          <li class="li">For a row that satisfies all of the <samp class="ph codeph">PATTERN</samp> criteria, the value of the
            <samp class="ph codeph">OUTPUT</samp> clause is applied. Otherwise the output is NULL for rows that don’t
            meet all of the <samp class="ph codeph">PATTERN</samp> criteria.</li>

        </ol>

      </div>

      <div class="fig fignone"><img class="image" src="../../images/./dataset/computed_fields/esp_example_processing_steps.png"/>
        
      </div>

    </div>

   
    
    <div class="section"><h2 class="title sectiontitle">Return Value</h2>
      <p class="p">Returns one value per row of the same type as the <var class="keyword varname">output_expression</var> for
        rows that match the defined match pattern, otherwise returns <samp class="ph codeph">NULL</samp> for rows
        that do not match the pattern.</p>

      
        <div class="note note"><span class="notetitle">Note:</span> Output values are calculated during the lens build process using a special event
          series MapReduce job. Therefore, sample output values for a <samp class="ph codeph">PARTITION</samp>
          computed field cannot be shown in the dataset workspace.</div>

      
    </div>

    
    <div class="section"><h2 class="title sectiontitle">Input Parameters</h2>
      
      <dl class="dl parml">
        
          <dt class="dt pt dlterm">PARTITION BY <var class="keyword varname">field_name</var></dt>

          <dd class="dd pd"><p class="p">Required. The <samp class="ph codeph">PARTITION BY</samp> clause is used to specify a field in the current
              dataset by which to partition the rows. Rows that share the same value for this field
              will be grouped together, and each group will then be processed independently
              according to the matching pattern criteria. </p>

            
              <div class="note note"><span class="notetitle">Note:</span> The partition field cannot be a field of a referenced dataset; it must be a
              field in the current focus dataset. </div>

                 </dd>

        
        
          <dt class="dt pt dlterm">ORDER BY <var class="keyword varname">field_name</var></dt>

          <dd class="dd pd"><p class="p">Optional. The <samp class="ph codeph">ORDER BY</samp> clause specifies a field by which to sort the rows within
              each partition before applying the match pattern criteria. For event series
              processing, records are typically ordered by a <samp class="ph codeph">DATETIME</samp> type field,
              such as a date or a timestamp. The default sort order is ascending (first to last or
              low to high). </p>

            
              <div class="note note"><span class="notetitle">Note:</span> The ordering field cannot be a field of a referenced dataset; it must be a field
              in the current focus dataset.</div>

             </dd>

        
        
          <dt class="dt pt dlterm">PATTERN (<var class="keyword varname">pattern_expression</var>)</dt>

          <dd class="dd pd"><p class="p">Required. The <samp class="ph codeph">PATTERN</samp> clause specifies the matching pattern to search for within
              a partition of rows. The <var class="keyword varname">pattern_expression</var> is expressed in a
              format similar to a <a class="xref" href="../regular_expressions/regex_ref_top.html" title="Regular expressions, also referred to as regex or regexp, are a standardized collection of special characters and constructs used for matching strings of text. They provide a flexible and precise language for matching particular characters, words, or patterns of characters. Regular expressions vary in complexity using a combination of basic constructs to describe a string matching pattern. This reference describes the most common regular expression matching patterns, but is not a comprehensive list.">regular expression</a>. The
                <var class="keyword varname">pattern_expression</var> can include:</p>

            <div class="p">
              <ul class="ul">
                <li class="li">A <samp class="ph codeph"><var class="keyword varname">symbol</var></samp> that represents some match criteria
                  (as declared in the <samp class="ph codeph">DEFINE</samp> clause). </li>

                <li class="li">A <samp class="ph codeph"><var class="keyword varname">symbol</var></samp> followed by one of the following
                    <a class="xref" href="../regular_expressions/regex_quantifiers.html" title="Quantifiers specify how often the preceding regular expression construct should match. There are three classes of quantifiers: greedy, reluctant, and possessive. The difference between greedy, reluctant, and possessive quantifiers involves what part of the string to try for the initial match, and how to retry if the initial attempt does not produce a match.">regex quantifiers</a>: <p class="p"><samp class="ph codeph">?</samp>
                    (matches once or not at all - greedy construct) </p>
<p class="p"><samp class="ph codeph">??</samp>
                    (matches once or not at all - reluctant construct)</p>
<p class="p"><samp class="ph codeph">*</samp>
                    (matches zero or more times - greedy construct)</p>
<p class="p"><samp class="ph codeph">*?</samp>
                    (matches zero or more times - reluctant construct)</p>
<p class="p"><samp class="ph codeph">+</samp>
                    (matches one or more times - greedy construct)</p>
<p class="p"><samp class="ph codeph">+?</samp>
                    (matches one or more times - reluctant construct)</p>
</li>

                <li class="li">
                  <p class="p">A <samp class="ph codeph"><var class="keyword varname">symbol</var></samp> or <var class="keyword varname">pattern</var> of
                    symbols anchored by the <a class="xref" href="../regular_expressions/regex_metacharacters.html" title="The most basic form of regular expression pattern matching is the match of a literal character or string. Regular expressions also have a number of special characters that affect the way a pattern is matched. This section describes the regular expression syntax for referring to literal characters, special characters, non-printable characters (such as a tab or a newline), and special character escaping.">regex special
                      characters</a> for the beginning and end of string.</p>

                  <p class="p"><samp class="ph codeph">^</samp> (marks the beginning of the set of rows that match to the
                    pattern) </p>

                  <p class="p"><samp class="ph codeph">$</samp> (marks the end of the set of rows that match to the
                    pattern)</p>

                </li>

                <li class="li"><samp class="ph codeph"><var class="keyword varname">patternA</var>|<var class="keyword varname">patternB</var></samp> - The
                    <em class="ph i">alternation</em> operator (pipe symbol) between two symbols or patterns
                  signifies an <samp class="ph codeph">OR</samp> match. </li>

                <li class="li"><samp class="ph codeph"><var class="keyword varname">patternA</var>,<var class="keyword varname">patternB</var></samp> - The
                    <em class="ph i">concatenation</em> operator (comma) between two symbols or patterns signifies
                  a match when pattern B <em class="ph i">immediately follows</em> pattern A. </li>

                <li class="li"><samp class="ph codeph"><var class="keyword varname">patternA</var>-&gt;<var class="keyword varname">patternB</var></samp> - The
                    <em class="ph i">follows</em> operator (minus and greater-than sign) between two symbols or
                  patterns signifies a match when pattern B <em class="ph i">eventually follows</em> pattern
                  A.</li>

                <li class="li"><p class="p"><samp class="ph codeph">(<var class="keyword varname">pattern_expression</var>)</samp> - By default, pattern
                  expressions are matched from left to right. If parenthesis are used to group
                  sub-expressions, the sub-expression within the parenthesis is evaluated first.</p>

                  <p class="p">You cannot use quantifiers outside of parenthesis. For example, you cannot
                    write ((A,B,C)*), to indicate that the asterisk quantifier applies to the whole
                    (A,B,C) expression.</p>
 </li>

              </ul>

            </div>
  </dd>

        
        
          <dt class="dt pt dlterm">DEFINE <var class="keyword varname">symbol</var> AS <var class="keyword varname">filter_expression</var></dt>

          <dd class="dd pd">
            <p class="p">Required. The <samp class="ph codeph">DEFINE</samp> clause is used to enumerate symbols used in the
                <samp class="ph codeph">PATTERN</samp> clause (or in the <var class="keyword varname">filter_expression</var> of a
              subsequent <var class="keyword varname">symbol</var> definition). </p>

            <p class="p">A <var class="keyword varname">symbol</var> is a name used to refer to some pattern matching
              criteria. This can be any name or token that follows Platfora's object naming rules.
              For example, if the name contains spaces, special characters, keywords, or starts with
              a number, you must enclose the name in brackets <samp class="ph codeph">[]</samp> to escape it.
              Otherwise, this can be any logical name that helps you identify a piece of pattern
              matching logic in your expression. </p>

            <p class="p">The <var class="keyword varname">filter_expression</var> is a Boolean (true or false) expression that
              operates on each row of the partition.</p>

            <p class="p">A <var class="keyword varname">filter_expression</var> can contain:</p>

            <div class="p">
              <ul class="ul">
                <li class="li"><p class="p">The special expression <samp class="ph codeph">TRUE</samp> or <samp class="ph codeph">1</samp>, meaning allow the match to
                    occur for any row in the partition.</p>
</li>

                <li class="li"><p class="p">Any <var class="keyword varname">field_name</var> in the current dataset.</p>
</li>

                <li class="li">
                  <p class="p"><var class="keyword varname">symbol.field_name</var> - A field from the dataset qualified by
                    the name of a symbol that (1) appears only once in the <samp class="ph codeph">PATTERN</samp>
                    clause, (2) preceeds this symbol in the <samp class="ph codeph">PATTERN</samp> clause, and (3)
                    is <em class="ph i">not</em> followed by a repetition quantifier in the
                      <samp class="ph codeph">PATTERN</samp> clause.</p>

                  <p class="p">For example:</p>

                  <p class="p"><samp class="ph codeph">PATTERN (A, B) DEFINE A AS TRUE, B AS product = A.product</samp></p>

                  <p class="p">This means that the expression for symbol <samp class="ph codeph">B</samp> will match to a
                    row if the <samp class="ph codeph">product</samp> field for that row is also equal to the
                      <samp class="ph codeph">product</samp> field for the row that is bound to symbol
                      <samp class="ph codeph">A</samp>. </p>

                </li>

                <li class="li">
                  <p class="p">Any of the <a class="xref" href="operators_comparison.html" title="Comparison operators are used to compare the equivalency of two expressions of the same data type. The result of a comparison expression is a Boolean value (returns 1 for true, 0 for false, or NULL for invalid). Boolean expressions are most often used to specify data processing conditions or filter criteria.">comparison operators</a>,
                    such as greater than, less than, equals, and so on.</p>

                </li>

                <li class="li">
                  <p class="p">The keywords <samp class="ph codeph">AND</samp> or <samp class="ph codeph">OR</samp> (for combining
                    multiple criteria in a single filter expression)</p>

                </li>

                <li class="li"><samp class="ph codeph">FIRST|LAST(<var class="keyword varname">symbol.field_name</var>)</samp> - A field from
                  the dataset, qualified by the name of a symbol that (1) only appears once in the
                    <samp class="ph codeph">PATTERN</samp> clause, (2) preceeds this symbol in the
                    <samp class="ph codeph">PATTERN</samp> clause, and (3) is followed by a repetition quantifier
                  in the <samp class="ph codeph">PATTERN</samp> clause
                    (<samp class="ph codeph">*</samp>,<samp class="ph codeph">*?</samp>,<samp class="ph codeph">+</samp>, or
                    <samp class="ph codeph">+?</samp>). This returns the field value for the first or last row
                  when the pattern matches to a set of rows. <p class="p">For example:</p>
<p class="p"><samp class="ph codeph">PATTERN
                      (A+) DEFINE A AS product = FIRST(A.product) OR COUNT(A)=0</samp></p>
<p class="p">The
                    pattern <samp class="ph codeph">A+</samp> will match to a series of consecutive rows that all
                    have the same value for the <samp class="ph codeph">product</samp> field as the first row in
                    the sequence. If the current row happens to be the first row in the sequence,
                    then it will also be included in the match.</p>
<div class="p">
                    <div class="note note"><span class="notetitle">Note:</span> A <samp class="ph codeph">FIRST</samp> or <samp class="ph codeph">LAST</samp> expression evaluates to
                        <samp class="ph codeph">NULL</samp> if it refers to a symbol that ends up matching an
                      empty sequence. Make sure your expression handles the row at the beginning or
                      end of a sequence if you want that row to match as well. </div>

                  </div>
</li>

                
                   
                <li class="li"><p class="p">Any computed expression that operates on the fields or expressions listed above and/or on literal
                    values.</p>
 </li>

              </ul>

            </div>

            <p class="p"> </p>

          </dd>

          
        
        
          <dt class="dt pt dlterm">OUTPUT <var class="keyword varname">output_expression</var></dt>

          <dd class="dd pd"><p class="p">Required. An expression that specifies what the output value should be. The output expression can
              refer to:</p>

            <div class="p">
              <ul class="ul">
                <li class="li"><p class="p">The field declared in the <samp class="ph codeph">PARTITION BY</samp> clause.</p>
</li>

                <li class="li"><p class="p"><var class="keyword varname">symbol.field_name</var> - A field from the dataset, qualified by
                  the name of a symbol that (1) appears only once in the <samp class="ph codeph">PATTERN</samp>
                  clause, and (2) is not followed by a repetition quantifier in the
                    <samp class="ph codeph">PATTERN</samp> clause. This will output the matching field value.</p>
</li>

                <li class="li"><p class="p"><samp class="ph codeph">COUNT(<var class="keyword varname">symbol</var>)</samp> where <var class="keyword varname">symbol</var> (1) appears
                    only once in the <samp class="ph codeph">PATTERN</samp> clause, and (2) is followed by a
                    repetition quantifier in the <samp class="ph codeph">PATTERN</samp> clause. This will output
                    the sequence number of the row that matched the symbol pattern.</p>
 </li>

                <li class="li">
                  <p class="p"><samp class="ph codeph">FIRST | LAST | SUM | COUNT | DISTINCT |
                        AVG(<var class="keyword varname">symbol.field_name</var>)</samp> where
                      <var class="keyword varname">symbol</var> (1) appears only once in the
                      <samp class="ph codeph">PATTERN</samp> clause, and (2) is followed by a repetition
                    quantifier in the <samp class="ph codeph">PATTERN</samp> clause. This will output an
                    aggregated value for a set of rows that matched the symbol pattern. </p>

                </li>

                <li class="li">
                  <p class="p">Since you can only output a single column value, you can use the <a class="xref" href="function_pack_values.html" title="PACK_VALUES is a row function that returns multiple output values packed into a single string of key/value pairs separated by the Platfora default key and pair separators. This is useful when the OUTPUT clause of a PARTITION expression returns multiple output values. The string returned is in a format that can be read by the EXTRACT_VALUE function. PACK_VALUES uses the same key and pair separator values that EXTRACT_VALUE uses (the Unicode escape sequences u0003 and u0002, respectively).">PACK_VALUES</a> function to output multiple results in a
                    single column as key/value pairs.</p>

                </li>

              </ul>

            </div>
</dd>

        
      </dl>

    </div>

    <div class="section"><h2 class="title sectiontitle">Examples</h2>
      
      <p class="p"><strong class="ph b">'Session Start Time' Expression</strong></p>

      <p class="p">Calculate a user session by partitioning by user and ordering by time. The matching logic
        represented by symbol <samp class="ph codeph">A</samp> checks if the time of the current row is less than
        30 minutes from the preceding row. If it is, then it is considered part of the same session
        as the previous row. Otherwise, the current row is considered the start of a new session.
        The <samp class="ph codeph">PATTERN (A+)</samp> means that the matching logic represented by symbol
          <samp class="ph codeph">A</samp> must be true for one or more consecutive rows. The output then returns
        the time of the first row in a session.</p>

      <pre class="pre codeblock">PARTITION BY UserID
   ORDER BY Timestamp
   PATTERN (A+) 
   DEFINE A AS COUNT(A)=0 
      OR MINUTES_BETWEEN(Timestamp,LAST(A.Timestamp)) &lt; 30 
   OUTPUT FIRST(A. Timestamp)</pre>

      
      
      <p class="p"><strong class="ph b">'Click Number in Session' Expression</strong></p>

      <p class="p">Calculate where a click happened in a session by partitioning by session and ordering by
        time. The matching logic represented by symbol <samp class="ph codeph">A</samp> simply matches to any row
        in the session. The <samp class="ph codeph">PATTERN (A+)</samp> means that the matching logic represented
        by symbol <samp class="ph codeph">A</samp> must be true for one or more consecutive rows. The output then
        returns to count of the row within the partition (based on its order or position in the
        partition).</p>

      <pre class="pre codeblock">PARTITION BY [Session ID] 
   ORDER BY Timestamp 
   PATTERN (A+) 
   DEFINE A AS TRUE 
   OUTPUT COUNT(A)</pre>

      
      <p class="p"><strong class="ph b">'Path to Page' Expression</strong></p>

      <p class="p">This is a complicated expression that looks back from the current row's position to
        determine the previous 4 pages viewed in a session. Since a <samp class="ph codeph">PARTITION</samp>
        expression can only output one column value as its result, the <samp class="ph codeph">OUTPUT</samp>
        clause uses the <a class="xref" href="function_pack_values.html" title="PACK_VALUES is a row function that returns multiple output values packed into a single string of key/value pairs separated by the Platfora default key and pair separators. This is useful when the OUTPUT clause of a PARTITION expression returns multiple output values. The string returned is in a format that can be read by the EXTRACT_VALUE function. PACK_VALUES uses the same key and pair separator values that EXTRACT_VALUE uses (the Unicode escape sequences u0003 and u0002, respectively).">PACK_VALUES</a> function to return the previous
        page positions 1,2,3, and 4 in one output value. You can then use a series of <a class="xref" href="function_extract_value.html" title="EXTRACT_VALUE is a row function that extracts the value for the given key from a string containing delimited key/value pairs.">EXTRACT_VALUE</a> expressions to create individual columns for each
        prior page view in the path. </p>

      <pre class="pre codeblock">PARTITION BY SessionID 
ORDER BY Timestamp
PATTERN (^OtherPreviousPages*?, Page4Back??, Page3Back??, Page2Back??, Page1Back??, CurrentPage) 
DEFINE OtherPreviousPages AS TRUE,
       Page4Back AS TRUE,
       Page3Back AS TRUE,
       Page2Back AS TRUE,
       Page1Back AS TRUE,
       CurrentPage AS TRUE
OUTPUT PACK_VALUES("Back4",Page4Back.Page, "Back3",Page3Back.Page, "Back2",Page2Back.Page, "Back1",Page1Back.Page)</pre>

      
      <p class="p"><strong class="ph b">‘Page -1 Back’ Expression</strong></p>

      <p class="p">Use the output from the <em class="ph i">Path to Page</em> expression and extract the last page viewed
        before the current page.</p>

      <pre class="pre codeblock">EXTRACT_VALUE([Path to Page],"Back1")</pre>

    </div>

  </div>

<div class="related-links"/>
<div class="navfooter"><!---->
<span class="navparent"><a class="link" href="../../reference/expression_language/row_general_functions_top.html" title="General processing functions allow you to perform basic data evaluation operations, such as checking for NULL values or processing values based on certain input conditions."><span class="navheader_label">Parent topic</span><span class="navheader_separator">: </span><span class="navheader_linktext">General Processing Functions</span></a></span>  </div><div class="footer">WebHelp output generated by<a href="http://www.oxygenxml.com" target="_blank"><span class="oXygenLogo"><img src="../../oxygen-webhelp/resources/img/LogoOxygen100x22.png" alt="Oxygen"/></span><span class="xmlauthor">XML Author</span></a></div>
<div id="productInfo" style="display:none;"><span id="oxy_productID">webhelp</span><span id="oxy_productVersion">3.0</span></div><div id="loginData" style="display: none"><span class="bt_close" title="Close"><!----></span><form action="" target="passwordIframe" method="post" name="form_login" onsubmit="return loggInUser();" id="loginFormData" autocomplete="on"><input type="hidden" id="reloadComments" value="yes"><!----></input><table class="login"><thead><tr><td colspan="2"><span id="l_login2"><script type="text/javascript">$('#l_login2').html(getLocalization('label.login'));</script></span></td></tr><tr><td colspan="2"><div id="loginResponse"><!----></div></td></tr></thead><tr><td><span id="l_userName"><script type="text/javascript">$('#l_userName').html(getLocalization('label.userName'));</script></span></td><td><input name="usernameW" type="text" id="myUserName" autocomplete="on" required="required" autofocus="autofocus"><!----></input></td></tr><tr><td><span id="l_pswd"><script type="text/javascript">$('#l_pswd').html(getLocalization('label.pswd'));</script></span></td><td><input name="passwordW" type="password" id="myPassword" autocomplete="on" required="required"><!----></input></td></tr><tr><td colspan="2" align="left"><span id="ll_remember"><script type="text/javascript" xml:space="preserve">
								$('#ll_remember').html(getLocalization('label.rememberme'));
							</script></span>     <input name="myLoginRemember" type="checkbox" class="ck" id="myRemember" value="no"><!----></input></td></tr><tr><td colspan="2" align="center"><input id="l_bt_submit_log" type="submit" value="Submit" name="loginFormButton"><!----></input><script type="text/javascript">$('#l_bt_submit_log').attr('value',getLocalization('label.login'));</script><span class="btnHGlue"><!----></span><input class="bt_cancel" id="l_cancelLog" type="button" value="Cancel" name="loginFormButton"><!----></input><script type="text/javascript">$('#l_cancelLog').attr('value',getLocalization('label.cancel'));</script></td></tr></table><div class="loginAlternative"><span id="link_lostPwd" onclick="showLostPwd()"><script type="text/javascript">$('#link_lostPwd').html(getLocalization('label.lostPswd'));</script></span><span id="link_signUp" onclick="showSignUp()"><script type="text/javascript">$('#link_signUp').html(getLocalization('label.signUp'));</script></span></div></form><iframe id="passwordIframe" name="passwordIframe" style="display:none"><!----></iframe></div><div id="cmts"><!----></div></body>
</html>